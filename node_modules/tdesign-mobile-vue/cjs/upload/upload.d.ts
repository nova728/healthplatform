/// <reference types="node" />
import { UploadFile } from './type';
declare const _default: import("vue").DefineComponent<{
    accept: {
        type: StringConstructor;
        default: string;
    };
    action: {
        type: StringConstructor;
        default: string;
    };
    addContent: {
        type: import("vue").PropType<string | ((h: typeof import("vue").h) => import("..").SlotReturnValue)>;
    };
    allowUploadDuplicateFile: BooleanConstructor;
    autoUpload: {
        type: BooleanConstructor;
        default: boolean;
    };
    beforeAllFilesUpload: {
        type: import("vue").PropType<(file: UploadFile[]) => boolean | Promise<boolean>>;
    };
    beforeUpload: {
        type: import("vue").PropType<(file: UploadFile) => boolean | Promise<boolean>>;
    };
    data: {
        type: import("vue").PropType<Record<string, any> | ((files: UploadFile[]) => Record<string, any>)>;
    };
    disabled: BooleanConstructor;
    fileListDisplay: {
        type: import("vue").PropType<(h: typeof import("vue").h, props: {
            files: UploadFile[];
            dragEvents?: import("..").UploadDisplayDragEvents;
        }) => import("..").SlotReturnValue>;
    };
    files: {
        type: import("vue").PropType<UploadFile[]>;
        default: any;
    };
    defaultFiles: {
        type: import("vue").PropType<UploadFile[]>;
        default: () => UploadFile[];
    };
    format: {
        type: import("vue").PropType<(file: File) => UploadFile>;
    };
    formatRequest: {
        type: import("vue").PropType<(requestData: {
            [key: string]: any;
        }) => {
            [key: string]: any;
        }>;
    };
    formatResponse: {
        type: import("vue").PropType<(response: any, context: import("./type").FormatResponseContext) => import("./type").ResponseType>;
    };
    headers: {
        type: import("vue").PropType<{
            [key: string]: string;
        }>;
    };
    imageProps: {
        type: import("vue").PropType<import("../image").TdImageProps>;
    };
    isBatchUpload: BooleanConstructor;
    max: {
        type: NumberConstructor;
        default: number;
    };
    method: {
        type: import("vue").PropType<"get" | "options" | "post" | "POST" | "GET" | "PUT" | "OPTIONS" | "PATCH" | "put" | "patch">;
        default: "get" | "options" | "post" | "POST" | "GET" | "PUT" | "OPTIONS" | "PATCH" | "put" | "patch";
        validator(val: "get" | "options" | "post" | "POST" | "GET" | "PUT" | "OPTIONS" | "PATCH" | "put" | "patch"): boolean;
    };
    mockProgressDuration: {
        type: NumberConstructor;
    };
    multiple: BooleanConstructor;
    name: {
        type: StringConstructor;
        default: string;
    };
    requestMethod: {
        type: import("vue").PropType<(files: UploadFile | UploadFile[]) => Promise<import("./type").RequestMethodResponse>>;
    };
    sizeLimit: {
        type: import("vue").PropType<number | import("./type").SizeLimitObj>;
    };
    useMockProgress: {
        type: BooleanConstructor;
        default: boolean;
    };
    uploadAllFilesInOneRequest: BooleanConstructor;
    value: {
        type: import("vue").PropType<UploadFile[]>;
        default: any;
    };
    modelValue: {
        type: import("vue").PropType<UploadFile[]>;
        default: any;
    };
    defaultValue: {
        type: import("vue").PropType<UploadFile[]>;
        default: () => UploadFile[];
    };
    withCredentials: BooleanConstructor;
    onCancelUpload: import("vue").PropType<() => void>;
    onChange: import("vue").PropType<(value: UploadFile[], context: import("./type").UploadChangeContext) => void>;
    onFail: import("vue").PropType<(options: import("./type").UploadFailContext) => void>;
    onOneFileFail: import("vue").PropType<(options: import("./type").UploadFailContext) => void>;
    onOneFileSuccess: import("vue").PropType<(context: Pick<import("./type").SuccessContext, "XMLHttpRequest" | "e" | "file" | "response">) => void>;
    onPreview: import("vue").PropType<(options: {
        file: UploadFile;
        index: number;
        e: MouseEvent;
    }) => void>;
    onProgress: import("vue").PropType<(options: import("./type").ProgressContext) => void>;
    onRemove: import("vue").PropType<(context: import("./type").UploadRemoveContext) => void>;
    onSelectChange: import("vue").PropType<(files: File[], context: import("./type").UploadSelectChangeContext) => void>;
    onSuccess: import("vue").PropType<(context: import("./type").SuccessContext) => void>;
    onValidate: import("vue").PropType<(context: {
        type: import("./type").UploadValidateType;
        files: UploadFile[];
    }) => void>;
    onWaitingUploadFilesChange: import("vue").PropType<(context: {
        files: UploadFile[];
        trigger: "remove" | "validate" | "uploaded";
    }) => void>;
    onClickUpload: import("vue").PropType<(context: {
        e: MouseEvent;
    }) => void>;
}, {
    uploadClass: import("vue").ComputedRef<string>;
    globalConfig: import("vue").ComputedRef<{} & import("..").UploadConfig>;
    initialIndex: import("vue").Ref<number>;
    showViewer: import("vue").Ref<boolean>;
    previewImgs: import("vue").ComputedRef<string[]>;
    toUploadFiles: import("vue").Ref<{
        [x: string]: any;
        lastModified?: number;
        name?: string;
        percent?: number;
        raw?: {
            readonly lastModified: number;
            readonly name: string;
            readonly webkitRelativePath: string;
            readonly size: number;
            readonly type: string;
            arrayBuffer: {
                (): Promise<ArrayBuffer>;
                (): Promise<ArrayBuffer>;
            };
            slice: {
                (start?: number, end?: number, contentType?: string): Blob;
                (start?: number, end?: number, contentType?: string): Blob;
            };
            stream: {
                (): ReadableStream<Uint8Array>;
                (): NodeJS.ReadableStream;
            };
            text: {
                (): Promise<string>;
                (): Promise<string>;
            };
        };
        response?: {
            [key: string]: any;
        };
        size?: number;
        status?: "progress" | "waiting" | "success" | "fail";
        type?: string;
        uploadTime?: string;
        url?: string;
    }[]>;
    uploadValue: import("vue").Ref<UploadFile[]>;
    displayFiles: import("vue").ComputedRef<UploadFile[]>;
    sizeOverLimitMessage: import("vue").Ref<string>;
    uploading: import("vue").Ref<boolean>;
    inputRef: import("vue").Ref<HTMLInputElement>;
    disabled: import("vue").Ref<boolean>;
    xhrReq: import("vue").Ref<{
        files: {
            [x: string]: any;
            lastModified?: number;
            name?: string;
            percent?: number;
            raw?: {
                readonly lastModified: number;
                readonly name: string;
                readonly webkitRelativePath: string;
                readonly size: number;
                readonly type: string;
                arrayBuffer: {
                    (): Promise<ArrayBuffer>;
                    (): Promise<ArrayBuffer>;
                };
                slice: {
                    (start?: number, end?: number, contentType?: string): Blob;
                    (start?: number, end?: number, contentType?: string): Blob;
                };
                stream: {
                    (): ReadableStream<Uint8Array>;
                    (): NodeJS.ReadableStream;
                };
                text: {
                    (): Promise<string>;
                    (): Promise<string>;
                };
            };
            response?: {
                [key: string]: any;
            };
            size?: number;
            status?: "progress" | "waiting" | "success" | "fail";
            type?: string;
            uploadTime?: string;
            url?: string;
        }[];
        xhrReq: {
            onreadystatechange: (this: XMLHttpRequest, ev: Event) => any;
            readonly readyState: number;
            readonly response: any;
            readonly responseText: string;
            responseType: XMLHttpRequestResponseType;
            readonly responseURL: string;
            readonly responseXML: Document;
            readonly status: number;
            readonly statusText: string;
            timeout: number;
            readonly upload: {
                addEventListener: {
                    <K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                    (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                };
                removeEventListener: {
                    <K_1 extends keyof XMLHttpRequestEventTargetEventMap>(type: K_1, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                    (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                };
                onabort: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
                onerror: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
                onload: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
                onloadend: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
                onloadstart: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
                onprogress: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
                ontimeout: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
                dispatchEvent: (event: Event) => boolean;
            };
            withCredentials: boolean;
            abort: () => void;
            getAllResponseHeaders: () => string;
            getResponseHeader: (name: string) => string;
            open: {
                (method: string, url: string | URL): void;
                (method: string, url: string | URL, async: boolean, username?: string, password?: string): void;
            };
            overrideMimeType: (mime: string) => void;
            send: (body?: Document | XMLHttpRequestBodyInit) => void;
            setRequestHeader: (name: string, value: string) => void;
            readonly DONE: number;
            readonly HEADERS_RECEIVED: number;
            readonly LOADING: number;
            readonly OPENED: number;
            readonly UNSENT: number;
            addEventListener: {
                <K_2 extends keyof XMLHttpRequestEventMap>(type: K_2, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K_2]) => any, options?: boolean | AddEventListenerOptions): void;
                (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
            };
            removeEventListener: {
                <K_3 extends keyof XMLHttpRequestEventMap>(type: K_3, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K_3]) => any, options?: boolean | EventListenerOptions): void;
                (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
            };
            onabort: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
            onerror: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
            onload: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
            onloadend: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
            onloadstart: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
            onprogress: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
            ontimeout: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
            dispatchEvent: (event: Event) => boolean;
        };
    }[]>;
    handlePreview: (e: MouseEvent, file: UploadFile, index: number) => void;
    triggerUpload: (e: MouseEvent) => void;
    uploadFilePercent: (params: {
        file: UploadFile;
        percent: number;
    }) => void;
    uploadFiles: (toFiles?: UploadFile[]) => void;
    onFileChange: (files: File[]) => void;
    onNormalFileChange: (e: Event) => void;
    onInnerRemove: (p: import("./type").UploadRemoveContext) => void;
    cancelUpload: (context?: {
        file?: UploadFile;
        e?: MouseEvent;
    }) => void;
    handleImageClose: ({ visible }: {
        visible: boolean;
    }) => void;
    renderStatus: (file: UploadFile) => JSX.Element;
    content: () => JSX.Element;
    defaultValue: import("vue").Ref<UploadFile[]>;
    name: import("vue").Ref<string>;
    multiple: import("vue").Ref<boolean>;
    max: import("vue").Ref<number>;
    action: import("vue").Ref<string>;
    defaultFiles: import("vue").Ref<UploadFile[]>;
    method: import("vue").Ref<"get" | "options" | "post" | "POST" | "GET" | "PUT" | "OPTIONS" | "PATCH" | "put" | "patch">;
    withCredentials: import("vue").Ref<boolean>;
    useMockProgress: import("vue").Ref<boolean>;
    uploadAllFilesInOneRequest: import("vue").Ref<boolean>;
    isBatchUpload: import("vue").Ref<boolean>;
    allowUploadDuplicateFile: import("vue").Ref<boolean>;
    autoUpload: import("vue").Ref<boolean>;
    accept: import("vue").Ref<string>;
    data: import("vue").Ref<unknown>;
    value: import("vue").Ref<UploadFile[]>;
    onChange: import("vue").Ref<((value: UploadFile[], context: import("./type").UploadChangeContext) => void) & ((...args: any[]) => any)>;
    format: import("vue").Ref<(file: File) => UploadFile>;
    modelValue: import("vue").Ref<UploadFile[]>;
    onProgress: import("vue").Ref<((options: import("./type").ProgressContext) => void) & ((...args: any[]) => any)>;
    onValidate: import("vue").Ref<((context: {
        type: import("./type").UploadValidateType;
        files: UploadFile[];
    }) => void) & ((...args: any[]) => any)>;
    files: import("vue").Ref<UploadFile[]>;
    addContent: import("vue").Ref<string | ((h: typeof import("vue").h) => import("..").SlotReturnValue)>;
    beforeAllFilesUpload: import("vue").Ref<(file: UploadFile[]) => boolean | Promise<boolean>>;
    beforeUpload: import("vue").Ref<(file: UploadFile) => boolean | Promise<boolean>>;
    fileListDisplay: import("vue").Ref<(h: typeof import("vue").h, props: {
        files: UploadFile[];
        dragEvents?: import("..").UploadDisplayDragEvents;
    }) => import("..").SlotReturnValue>;
    formatRequest: import("vue").Ref<(requestData: {
        [key: string]: any;
    }) => {
        [key: string]: any;
    }>;
    formatResponse: import("vue").Ref<(response: any, context: import("./type").FormatResponseContext) => import("./type").ResponseType>;
    headers: import("vue").Ref<{
        [key: string]: string;
    }>;
    imageProps: import("vue").Ref<unknown>;
    requestMethod: import("vue").Ref<(files: UploadFile | UploadFile[]) => Promise<import("./type").RequestMethodResponse>>;
    sizeLimit: import("vue").Ref<number | import("./type").SizeLimitObj>;
    onCancelUpload: import("vue").Ref<() => void>;
    onFail: import("vue").Ref<((options: import("./type").UploadFailContext) => void) & ((...args: any[]) => any)>;
    onOneFileFail: import("vue").Ref<(options: import("./type").UploadFailContext) => void>;
    onOneFileSuccess: import("vue").Ref<(context: Pick<import("./type").SuccessContext, "XMLHttpRequest" | "e" | "file" | "response">) => void>;
    onPreview: import("vue").Ref<((options: {
        file: UploadFile;
        index: number;
        e: MouseEvent;
    }) => void) & ((...args: any[]) => any)>;
    onRemove: import("vue").Ref<((context: import("./type").UploadRemoveContext) => void) & ((...args: any[]) => any)>;
    onSelectChange: import("vue").Ref<(files: File[], context: import("./type").UploadSelectChangeContext) => void>;
    onSuccess: import("vue").Ref<((context: import("./type").SuccessContext) => void) & ((...args: any[]) => any)>;
    onWaitingUploadFilesChange: import("vue").Ref<(context: {
        files: UploadFile[];
        trigger: "remove" | "validate" | "uploaded";
    }) => void>;
    onClickUpload: import("vue").Ref<(context: {
        e: MouseEvent;
    }) => void>;
    mockProgressDuration: import("vue").Ref<number>;
    "onUpdate:modelValue": import("vue").Ref<(...args: any[]) => any>;
    "onUpdate:files": import("vue").Ref<(...args: any[]) => any>;
    "onSelect-change": import("vue").Ref<(...args: any[]) => any>;
    "onClick-upload": import("vue").Ref<(...args: any[]) => any>;
}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, ("progress" | "update:modelValue" | "change" | "success" | "validate" | "remove" | "fail" | "update:files" | "preview" | "select-change" | "click-upload")[], "progress" | "update:modelValue" | "remove" | "change" | "success" | "validate" | "fail" | "update:files" | "preview" | "select-change" | "click-upload", import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, Readonly<import("vue").ExtractPropTypes<{
    accept: {
        type: StringConstructor;
        default: string;
    };
    action: {
        type: StringConstructor;
        default: string;
    };
    addContent: {
        type: import("vue").PropType<string | ((h: typeof import("vue").h) => import("..").SlotReturnValue)>;
    };
    allowUploadDuplicateFile: BooleanConstructor;
    autoUpload: {
        type: BooleanConstructor;
        default: boolean;
    };
    beforeAllFilesUpload: {
        type: import("vue").PropType<(file: UploadFile[]) => boolean | Promise<boolean>>;
    };
    beforeUpload: {
        type: import("vue").PropType<(file: UploadFile) => boolean | Promise<boolean>>;
    };
    data: {
        type: import("vue").PropType<Record<string, any> | ((files: UploadFile[]) => Record<string, any>)>;
    };
    disabled: BooleanConstructor;
    fileListDisplay: {
        type: import("vue").PropType<(h: typeof import("vue").h, props: {
            files: UploadFile[];
            dragEvents?: import("..").UploadDisplayDragEvents;
        }) => import("..").SlotReturnValue>;
    };
    files: {
        type: import("vue").PropType<UploadFile[]>;
        default: any;
    };
    defaultFiles: {
        type: import("vue").PropType<UploadFile[]>;
        default: () => UploadFile[];
    };
    format: {
        type: import("vue").PropType<(file: File) => UploadFile>;
    };
    formatRequest: {
        type: import("vue").PropType<(requestData: {
            [key: string]: any;
        }) => {
            [key: string]: any;
        }>;
    };
    formatResponse: {
        type: import("vue").PropType<(response: any, context: import("./type").FormatResponseContext) => import("./type").ResponseType>;
    };
    headers: {
        type: import("vue").PropType<{
            [key: string]: string;
        }>;
    };
    imageProps: {
        type: import("vue").PropType<import("../image").TdImageProps>;
    };
    isBatchUpload: BooleanConstructor;
    max: {
        type: NumberConstructor;
        default: number;
    };
    method: {
        type: import("vue").PropType<"get" | "options" | "post" | "POST" | "GET" | "PUT" | "OPTIONS" | "PATCH" | "put" | "patch">;
        default: "get" | "options" | "post" | "POST" | "GET" | "PUT" | "OPTIONS" | "PATCH" | "put" | "patch";
        validator(val: "get" | "options" | "post" | "POST" | "GET" | "PUT" | "OPTIONS" | "PATCH" | "put" | "patch"): boolean;
    };
    mockProgressDuration: {
        type: NumberConstructor;
    };
    multiple: BooleanConstructor;
    name: {
        type: StringConstructor;
        default: string;
    };
    requestMethod: {
        type: import("vue").PropType<(files: UploadFile | UploadFile[]) => Promise<import("./type").RequestMethodResponse>>;
    };
    sizeLimit: {
        type: import("vue").PropType<number | import("./type").SizeLimitObj>;
    };
    useMockProgress: {
        type: BooleanConstructor;
        default: boolean;
    };
    uploadAllFilesInOneRequest: BooleanConstructor;
    value: {
        type: import("vue").PropType<UploadFile[]>;
        default: any;
    };
    modelValue: {
        type: import("vue").PropType<UploadFile[]>;
        default: any;
    };
    defaultValue: {
        type: import("vue").PropType<UploadFile[]>;
        default: () => UploadFile[];
    };
    withCredentials: BooleanConstructor;
    onCancelUpload: import("vue").PropType<() => void>;
    onChange: import("vue").PropType<(value: UploadFile[], context: import("./type").UploadChangeContext) => void>;
    onFail: import("vue").PropType<(options: import("./type").UploadFailContext) => void>;
    onOneFileFail: import("vue").PropType<(options: import("./type").UploadFailContext) => void>;
    onOneFileSuccess: import("vue").PropType<(context: Pick<import("./type").SuccessContext, "XMLHttpRequest" | "e" | "file" | "response">) => void>;
    onPreview: import("vue").PropType<(options: {
        file: UploadFile;
        index: number;
        e: MouseEvent;
    }) => void>;
    onProgress: import("vue").PropType<(options: import("./type").ProgressContext) => void>;
    onRemove: import("vue").PropType<(context: import("./type").UploadRemoveContext) => void>;
    onSelectChange: import("vue").PropType<(files: File[], context: import("./type").UploadSelectChangeContext) => void>;
    onSuccess: import("vue").PropType<(context: import("./type").SuccessContext) => void>;
    onValidate: import("vue").PropType<(context: {
        type: import("./type").UploadValidateType;
        files: UploadFile[];
    }) => void>;
    onWaitingUploadFilesChange: import("vue").PropType<(context: {
        files: UploadFile[];
        trigger: "remove" | "validate" | "uploaded";
    }) => void>;
    onClickUpload: import("vue").PropType<(context: {
        e: MouseEvent;
    }) => void>;
}>> & {
    onChange?: (...args: any[]) => any;
    onProgress?: (...args: any[]) => any;
    "onUpdate:modelValue"?: (...args: any[]) => any;
    onValidate?: (...args: any[]) => any;
    onFail?: (...args: any[]) => any;
    onPreview?: (...args: any[]) => any;
    onRemove?: (...args: any[]) => any;
    onSuccess?: (...args: any[]) => any;
    "onUpdate:files"?: (...args: any[]) => any;
    "onSelect-change"?: (...args: any[]) => any;
    "onClick-upload"?: (...args: any[]) => any;
}, {
    value: UploadFile[];
    defaultValue: UploadFile[];
    modelValue: UploadFile[];
    name: string;
    disabled: boolean;
    multiple: boolean;
    max: number;
    action: string;
    files: UploadFile[];
    defaultFiles: UploadFile[];
    method: "get" | "options" | "post" | "POST" | "GET" | "PUT" | "OPTIONS" | "PATCH" | "put" | "patch";
    withCredentials: boolean;
    useMockProgress: boolean;
    uploadAllFilesInOneRequest: boolean;
    isBatchUpload: boolean;
    allowUploadDuplicateFile: boolean;
    autoUpload: boolean;
    accept: string;
}, {}>;
export default _default;
