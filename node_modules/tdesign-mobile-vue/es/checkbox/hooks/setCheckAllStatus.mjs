/**
 * tdesign v1.5.0
 * (c) 2024 TDesign Group
 * @license MIT
 */

import { computed } from 'vue';
import '../../_chunks/dep-57a75b98.mjs';
import { _ as _arrayMap } from '../../_chunks/dep-12b97090.mjs';
import { _ as _SetCache, a as _arrayIncludes, b as _arrayIncludesWith, c as _cacheHas } from '../../_chunks/dep-45147d22.mjs';
import { _ as _baseUnary } from '../../_chunks/dep-32f76754.mjs';
import { i as isArrayLikeObject_1, _ as _baseRest } from '../../_chunks/dep-0d47707f.mjs';
import '../../_chunks/dep-4a0b07f2.mjs';
import '../../_chunks/dep-4f0b3d47.mjs';
import '../../_chunks/dep-14bda5a6.mjs';
import '../../_chunks/dep-c6268b4a.mjs';
import '../../_chunks/dep-b617aa7d.mjs';
import '../../_chunks/dep-c06e51c6.mjs';
import '../../_chunks/dep-4d5ede6c.mjs';
import '../../_chunks/dep-9f2b5648.mjs';
import '../../_chunks/dep-ce88baea.mjs';
import '../../_chunks/dep-06d482c6.mjs';
import '../../_chunks/dep-0bb5e0ba.mjs';
import '../../_chunks/dep-8eaf2b7e.mjs';

var SetCache = _SetCache,
  arrayIncludes = _arrayIncludes,
  arrayIncludesWith = _arrayIncludesWith,
  arrayMap$1 = _arrayMap,
  baseUnary = _baseUnary,
  cacheHas = _cacheHas;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * The base implementation of methods like `_.intersection`, without support
 * for iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */
function baseIntersection$1(arrays, iteratee, comparator) {
  var includes = comparator ? arrayIncludesWith : arrayIncludes,
    length = arrays[0].length,
    othLength = arrays.length,
    othIndex = othLength,
    caches = Array(othLength),
    maxLength = Infinity,
    result = [];
  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee) {
      array = arrayMap$1(array, baseUnary(iteratee));
    }
    maxLength = nativeMin(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
  }
  array = arrays[0];
  var index = -1,
    seen = caches[0];
  outer: while (++index < length && result.length < maxLength) {
    var value = array[index],
      computed = iteratee ? iteratee(value) : value;
    value = comparator || value !== 0 ? value : 0;
    if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
      othIndex = othLength;
      while (--othIndex) {
        var cache = caches[othIndex];
        if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
          continue outer;
        }
      }
      if (seen) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}
var _baseIntersection = baseIntersection$1;

var isArrayLikeObject = isArrayLikeObject_1;

/**
 * Casts `value` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */
function castArrayLikeObject$1(value) {
  return isArrayLikeObject(value) ? value : [];
}
var _castArrayLikeObject = castArrayLikeObject$1;

var arrayMap = _arrayMap,
  baseIntersection = _baseIntersection,
  baseRest = _baseRest,
  castArrayLikeObject = _castArrayLikeObject;

/**
 * Creates an array of unique values that are included in all given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersection([2, 1], [2, 3]);
 * // => [2]
 */
var intersection = baseRest(function (arrays) {
  var mapped = arrayMap(arrays, castArrayLikeObject);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
});
var intersection_1 = intersection;

var setCheckAllStatus = function setCheckAllStatus(optionList, innerValue, checkedSet) {
  var isArray = Array.isArray;
  var intersectionLen = computed(function () {
    var _optionList$value;
    var values = (_optionList$value = optionList.value) === null || _optionList$value === void 0 ? void 0 : _optionList$value.map(function (item) {
      return item.value;
    });
    if (isArray(innerValue.value)) {
      return intersection_1(innerValue.value, values).length;
    }
    return 0;
  });
  var isAllChecked = computed(function () {
    if (checkedSet.value.size !== optionList.value.length - 1) {
      return false;
    }
    return intersectionLen.value === optionList.value.length - 1;
  });
  var indeterminate = computed(function () {
    return !isAllChecked.value && intersectionLen.value < optionList.value.length && intersectionLen.value > 0;
  });
  return computed(function () {
    if (isAllChecked.value) return "checked";
    if (indeterminate.value) return "indeterminate";
    return "uncheck";
  });
};

export { setCheckAllStatus };
//# sourceMappingURL=setCheckAllStatus.mjs.map
